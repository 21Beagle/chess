var z=Object.defineProperty;var ee=(v,u,M)=>u in v?z(v,u,{enumerable:!0,configurable:!0,writable:!0,value:M}):v[u]=M;var s=(v,u,M)=>(ee(v,typeof u!="symbol"?u+"":u,M),M);(function(){"use strict";class v{constructor(e,t,i){s(this,"name");s(this,"id");s(this,"value");this.name=e,this.id=t,this.value=i}}const u={PAWN:new v("Pawn","P",1),KNIGHT:new v("Knight","N",3),KING:new v("King","K",0),QUEEN:new v("Queen","Q",9),ROOK:new v("Rook","R",5),BISHOP:new v("Bishop","B",3),EMPTY:new v("Empty","",0),NULL:new v("Null","-",-1)};function M(o){return o===o.toUpperCase()}function Y(o){return/^-?\d+$/.test(o)}let N;const j=new Uint8Array(16);function J(){if(!N&&(N=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!N))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return N(j)}const f=[];for(let o=0;o<256;++o)f.push((o+256).toString(16).slice(1));function X(o,e=0){return f[o[e+0]]+f[o[e+1]]+f[o[e+2]]+f[o[e+3]]+"-"+f[o[e+4]]+f[o[e+5]]+"-"+f[o[e+6]]+f[o[e+7]]+"-"+f[o[e+8]]+f[o[e+9]]+"-"+f[o[e+10]]+f[o[e+11]]+f[o[e+12]]+f[o[e+13]]+f[o[e+14]]+f[o[e+15]]}var K={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function L(o,e,t){if(K.randomUUID&&!e&&!o)return K.randomUUID();o=o||{};const i=o.random||(o.rng||J)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,e){t=t||0;for(let n=0;n<16;++n)e[t+n]=i[n];return e}return X(i)}class V{constructor(e,t,i,n,r){s(this,"castle");s(this,"enPassant");s(this,"colour");s(this,"halfMoveClock",0);s(this,"fullMoveClock",1);s(this,"id");s(this,"isCheckMate",!1);s(this,"isStaleMate",!1);this.castle=e,this.enPassant=t,this.colour=i,this.halfMoveClock=n,this.fullMoveClock=r,this.id=L()}copy(e=!1){if(this.enPassant===null){const i=new V(this.castle,null,this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(i.id=this.id),i}const t=new V(this.castle,this.enPassant.copy(),this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(t.id=this.id),t}}const p=class p{constructor(e){s(this,"id");s(this,"whiteId","W");s(this,"blackId","B");s(this,"blackName","Black");s(this,"whiteName","White");s(this,"nullId","");this.id=e}get isWhite(){return this.id===this.whiteId}get isBlack(){return this.id===this.blackId}get isNull(){return this.id===this.nullId}get name(){return this.isBlack?this.blackName:this.whiteName}changePlayer(){return this.id===this.nullId?p.Null:(this.id=this.isBlack?this.whiteId:this.blackId,this)}isEqual(e){return p.areSameColour(this,e)}get opposite(){return this.id===this.nullId?p.Null:this.isBlack?new p(this.whiteId):new p(this.blackId)}copy(){return new p(this.id)}static get Black(){return p._black}static get White(){return p._white}static get Null(){return p._null}static areSameColour(e,t){return e.id===t.id}static areDifferentColourAndNotNull(e,t){return e.isNull||t.isNull?!1:e.id!==t.id}};s(p,"_black",new p("B")),s(p,"_white",new p("W")),s(p,"_null",new p(""));let w=p;const c=class c{constructor(e){s(this,"_index",c._nullIndex);s(this,"_an",c._nullAn);s(this,"_rank",c._nullRank);s(this,"_file",c._nullFile);if(e!==null)switch(typeof e){case"string":this.parseAn(e);break;case"object":this.parsePosition(e);break;case"number":this.parseIndex(e);break;default:console.error("Position type not supported",e,typeof e);break}}get neighbours(){return this.index===null?{north:null,south:null,east:null,west:null,northEast:null,northWest:null,southEast:null,southWest:null}:{north:new c(this.index-8),south:new c(this.index+8),east:new c(this.index+1),west:new c(this.index-1),northEast:new c(this.index-7),northWest:new c(this.index-9),southEast:new c(this.index+9),southWest:new c(this.index+7)}}get index(){if(this._index===null)throw new Error("Position index is null");return this._index}set index(e){this.parseIndex(e),this._index=e}get an(){return this._an}set an(e){this.parseAn(e),this._an=e}get rank(){if(this._rank===null)throw new Error("Position rank is null");return this._rank}set rank(e){this.parseRank(e),this._rank=e}parseRank(e){return e===null&&this.setNull(),this._index=c.rankFileToIndex(e,this.file),this._an=c.indexToAn(this.index),this}get file(){if(this._file===null)throw new Error("Position file is null");return this._file}set file(e){this.parsefile(e),this._file=e}parsefile(e){return e===null&&this.setNull(),this._index=c.rankFileToIndex(this.rank,e),this._an=c.indexToAn(this.index),this}parsePosition(e){return this._index=e.index,this._rank=e.rank,this._file=e.file,this._an=e.an,this}parseAn(e){return e===c._nullAn?(this.setNull(),this):(this._index=c.anToIndex(e),this._index===null||this._index<0||this._index>63?(this.setNull(),this):(this._an=e,this._rank=c.getRankOfIndex(this.index),this._file=c.getRankOfIndex(this.index),this))}setNull(){throw this._index=c._nullIndex,this._an=c._nullAn,this._rank=c._nullRank,this._file=c._nullFile,new Error("Set a Position to null")}parseIndex(e){return e===null?(this.setNull(),this):c.isValidIndex(e)?(this._index=e,this._an=c.indexToAn(e),this._rank=c.getRankOfIndex(e),this._file=c.getFileOfIndex(e),this):(this.setNull(),this)}isEqual(e){return this.index===e.index}copy(){return new c(this)}static fileDifference(e,t){return e.file===null||t.file===null?1/0:Math.abs(e.file-t.file)}static indexToAn(e){if(e===null)return"-";const t="abcdefgh",i=e%8,n=8-Math.floor(e/8);return t[i]+n}static anToIndex(e){const i="abcdefgh".indexOf(e[0]),n=8-Number(e[1]);return i===-1||n===-1?null:n+i*8}static rankFileToIndex(e,t){return t===null||e===null?null:e+(7-t)*8}static getRankOfIndex(e){return e===null?null:7-Math.floor(e/8)}static getFileOfIndex(e){return e===null?null:e%8}static isValidIndex(e){return e===null?!1:e>=0&&e<=63}};s(c,"_nullIndex",null),s(c,"_nullAn","-"),s(c,"_nullRank",null),s(c,"_nullFile",null),s(c,"Null",new c(null));let l=c;class g{static getMoves(e,t){var i;try{const n=(i=this.moveCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static cacheMoves(e,t,i){this.moveCache[e]={[t]:i}}static clearCache(){console.log("Clearing cache"),this.moveCache={},this.evalCache={},this.scopeCache={}}static clearEvaluationCache(){this.evalCache={}}static cacheScope(e,t,i){this.scopeCache[e]={[t]:i}}static getScope(e,t){var i;try{const n=(i=this.scopeCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static getEvaluation(e){try{const t=this.evalCache[e];return t!==void 0?{result:!0,evaluation:t}:{result:!1,evaluation:0}}catch{return{result:!1,evaluation:0}}}static cacheEvaluation(e,t){this.evalCache[e]=t}}s(g,"moveCache",{}),s(g,"scopeCache",{}),s(g,"evalCache",{});class W{static validateScope(e,t){return t.skipValidate?!0:!(!t.nullValidate||!this.positionValidate(t)||!this.cantHaveMovedValidate(t)||!this.freePositionsValidation(e,t)||!this.isACaptureValidation(e,t)||!this.isAPromotionValidation(t)||!this.castleValidate(e,t))}static validate(e,t){return this.validateScope(e,t)&&!this.willPutPlayerInCheckValidation(e,t)}static castleValidate(e,t){const i=e.state.castle;return t.isCastleMove?i.includes(t.castleChange):!0}static willPutPlayerInCheckValidation(e,t){t.do(!1);const i=e.isCheck(t.piece.colour);return t.undo(),i}static isAPromotionValidation(e){if(e.piece.isPawn){const t=e.piece;return e.isPromotion&&e.end.rank===t.promotionRank||!e.isPromotion&&e.end.rank!==t.promotionRank}return!0}static positionValidate(e){return!(e.hasToStartAtRank&&e.start.rank!==e.hasToStartAtRank||l.fileDifference(e.start,e.end)>e.piece.maxFileDifference)}static cantHaveMovedValidate(e){return!(e.piece.hasMoved&&e.pieceCantHaveMoved)}static isACaptureValidation(e,t){if(t.endPiece.colour.isEqual(t.piece.colour))return!1;if(!t.mustBeCapture||t.isCapture)return!0;if(e.state.enPassant!==null&&t.canBeEnpassant&&t.piece.isPawn&&(t.isEnpassantTake=e.state.enPassant.isEqual(t.end),t.isEnpassantTake)){if(e.state.enPassant.neighbours.north===null||e.state.enPassant.neighbours.south==null)return!1;t.willDestroy.push(e.state.enPassant.neighbours.north,e.state.enPassant.neighbours.south)}return t.isEnpassantTake}static freePositionsValidation(e,t){return t.mustBeFree.every(i=>e.getPieceAtPosition(i).isEmpty)}}class k{constructor(e,t,i){s(this,"start");s(this,"end");s(this,"piece");s(this,"willCreateEnPassant",!1);s(this,"willDestroy",[]);s(this,"isAttack",!0);s(this,"isEnpassantTake",!1);s(this,"isCastleMove",!1);s(this,"enPassantPositionCreated",null);s(this,"canBeEnpassant",!1);s(this,"mustBeFree",[]);s(this,"mustBeCapture",!1);s(this,"canBeCapture",!0);s(this,"hasToStartAtRank",null);s(this,"skipValidate",!1);s(this,"changePlayerAfterMove",!0);s(this,"extraMoves",[]);s(this,"value",null);s(this,"endPiece");s(this,"pieceCantHaveMoved",!1);s(this,"destoryedPieces",[]);s(this,"stateBefore");s(this,"castleChange","");s(this,"game");s(this,"isPromotion",!1);s(this,"promotionPiece",u.EMPTY.id);s(this,"stateId");s(this,"valueCalculated",!1);s(this,"searchCalculatedValue",0);this.start=new l(e.position),this.end=new l(t),this.piece=e,this.game=i,this.endPiece=i.getPieceAtPosition(this.end),this.stateBefore=i.state.copy(!0),this.stateId=i.state.id}get stateAfter(){return this.constructStateAfter()}get isCheck(){return this.endPiece.isKing&&w.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get simpleEvaluation(){return this.endPiece.type.value+this.piece.valueGrid[this.end.index]}get isCapture(){return w.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get nullValidate(){return!!this.endPiece}destroyPositions(){this.willDestroy.forEach(e=>{this.destoryedPieces.push(this.game.board[e.index]),this.game.destroyPieceAtPosition(e)})}undoDestroyPositions(){for(const e of this.destoryedPieces)this.game.placePieceAtPosition(e,e.position);this.destoryedPieces=[]}constructStateAfter(){const e=this.stateBefore.copy();return this.castleChange!==""&&this.castleChange.split("").forEach(t=>{e.castle=e.castle.replace(t,"")}),this.enPassantPositionCreated!==null?e.enPassant=this.enPassantPositionCreated:e.enPassant=null,this.isCapture&&(e.halfMoveClock=0),e.halfMoveClock++,this.piece.colour.isBlack&&e.fullMoveClock++,e}doExtraMoves(e=!0){this.extraMoves.forEach(t=>{t.do(e)})}undoExtraMoves(){this.extraMoves.forEach(e=>{e.undo()})}handlePromotion(){if(this.isPromotion){const e=this.end.index;this.game.destroyPieceAtIndex(e);const t=this.piece.colour,i=_.generate(e,this.promotionPiece,t);this.game.placePieceAtPosition(i,this.end)}}undoPromotion(){this.isPromotion&&(this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.start))}validate(e){return W.validate(e,this)}validateScope(e){return W.validateScope(e,this)}do(e=!0){this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.end),this.game.state=this.stateAfter,this.destroyPositions(),this.handlePromotion(),this.doExtraMoves(e),e&&(this.game.moveHistory.push(this),g.clearCache())}undo(){this.game.placePieceAtPosition(this.piece,this.start),this.game.placePieceAtPosition(this.endPiece,this.end),this.game.state=this.stateBefore,this.undoDestroyPositions(),this.undoPromotion(),this.undoExtraMoves()}get algebraicNotation(){const e=this.piece.type.id,t=this.end.an,i=this.isCapture?"x":"",n=this.isPromotion?`=${this.promotionPiece}`:"",r=this.isCastleMove?"O-O":"";return`${e}${i}${t}${n}${r}`}}class y{constructor(e,t){s(this,"type");s(this,"colour");s(this,"selected");s(this,"hasMoved",!1);s(this,"maxFileDifference",0);s(this,"_position");s(this,"_moves",[]);s(this,"_scope",[]);s(this,"id");this._position=new l(e),this.colour=t,this.selected=!1,this.type=u.NULL,this.id=L()}get valueGrid(){return new Array(64).fill(0)}set position(e){this._position=new l(e)}get position(){return this._position}positionalValue(e){return e.index===null?0:this.colour.isBlack?this.valueGrid[63-e.index]:this.valueGrid[e.index]}get directions(){return this.colour.isBlack?{forward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},left:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},right:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},forwardLeft:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},forwardRight:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backwardLeft:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backwardRight:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)}}:{forward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},left:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},right:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},forwardLeft:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},forwardRight:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backwardLeft:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)},backwardRight:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!l.isValidIndex(t)?null:new l(t)}}}get moves(){return this._moves}get scope(){return this._scope}get isBlack(){return this.colour.isBlack}get isWhite(){return this.colour.isWhite}get isEmpty(){return this.type.id===u.EMPTY.id}get isKing(){return this.type.id===u.KING.id}get isPawn(){return this.type.id===u.PAWN.id}get isBishop(){return this.type.id===u.BISHOP.id}get isKnight(){return this.type.id===u.KNIGHT.id}get isRook(){return this.type.id===u.ROOK.id}get isQueen(){return this.type.id===u.QUEEN.id}generateMoves(e){const t=g.getMoves(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validate(e));return g.cacheMoves(this.id,e.state.id,i),i}_generateMoves(e){return console.log(this.type.name,e.state.id),[]}generateScope(e){const t=g.getScope(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validateScope(e));return g.cacheScope(this.id,e.state.id,i),i}select(){this.selected=!0}deselect(){this.selected=!1}directionMoveGenerator(e,t,i){for(let n=1;n<=8;n++){const r=t(n);if(!r)continue;const a=new k(this,r,i);for(let d=1;d<=n-1;d++)t(d)&&a.mustBeFree.push(new l(t(d)));const h=a.mustBeFree.length?a.mustBeFree[a.mustBeFree.length-1]:this.position;if(l.fileDifference(r,h)>1)return;e.push(a)}}appendMove(e,t,i){if(i!==null){const n=new k(this,i,e);t.push(n)}}}class T extends y{constructor(t,i){super(t,i);s(this,"VALUE_GRID_BISHOP",[0,0,0,0,0,0,0,1,1,2,0,0,0,0,2,1,2,3,3,3,3,3,3,2,2,3,4,4,4,4,3,2,3,5,6,5,5,6,5,3,5,6,6,4,4,6,6,5,6,6,4,4,4,4,6,6,0,0,0,0,0,0,0,0]);this.maxFileDifference=8,this.type=u.BISHOP}get valueGrid(){return this.VALUE_GRID_BISHOP}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),i}}s(T,"id","B"),s(T,"name","Bishop"),s(T,"value");class E extends y{constructor(e){super(e,w.Null),this.type=u.EMPTY}}s(E,"id",""),s(E,"name","Empty"),s(E,"value",0);class B extends y{constructor(t,i){super(t,i);s(this,"KING_VALUE_GRID",[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,2,2,2,2,1,0,0,1,2,4,4,2,1,0,0,1,2,4,4,2,1,0,0,1,2,2,2,2,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0]);this.maxFileDifference=5,this.type=u.KING}get valueGrid(){return this.KING_VALUE_GRID}castleMoves(t){let i,n,r,a,h,d,C,H,I;this.isBlack?(i=2,n=3,r=0,H=[1,2,3],I="q",a=6,h=5,d=7,C=[5,6],I="k"):(i=58,n=59,r=56,H=[57,58,59],I="Q",a=62,h=61,d=63,C=[61,62],I="K");const b=new k(this,i,t);b.isCastleMove=!0,b.isAttack=!1;const Q=new k(t.getPieceAtPosition(new l(r)),n,t);Q.changePlayerAfterMove=!1,b.extraMoves.push(Q);const m=new k(this,a,t);m.isCastleMove=!0,m.isAttack=!1;const q=new k(t.getPieceAtPosition(new l(d)),h,t);return q.changePlayerAfterMove=!1,m.extraMoves.push(q),m.castleChange=I,b.castleChange=I,b.mustBeFree=H.map(U=>new l(U)),m.mustBeFree=C.map(U=>new l(U)),[b,m]}_generateMoves(t){let i=[];return this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.backward(1)),this.appendMove(t,i,this.directions.left(1)),this.appendMove(t,i,this.directions.right(1)),this.appendMove(t,i,this.directions.backwardLeft(1)),this.appendMove(t,i,this.directions.backwardRight(1)),this.appendMove(t,i,this.directions.forwardLeft(1)),this.appendMove(t,i,this.directions.forwardRight(1)),i.forEach(n=>{n.castleChange="kqKQ"}),i=i.concat(this.castleMoves(t)),i}}s(B,"id","K"),s(B,"name","King"),s(B,"value");class R extends y{constructor(t,i){super(t,i);s(this,"maxFileDifference",2);s(this,"VALUE_GRID_KINGHT",[0,1,1,1,1,1,1,0,1,2,2,2,2,2,2,1,1,5,7,6,6,7,0,1,2,4,8,7,7,8,0,2,1,3,6,5,5,6,3,1,1,2,4,3,3,4,2,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0]);this.type=u.KNIGHT}get valueGrid(){return this.VALUE_GRID_KINGHT}get knightEndPositionShift(){return[10,-10,17,-17,15,-15,6,-6]}_generateMoves(t){const i=[];return this.knightEndPositionShift.forEach(n=>{const r=this.position.index+n;if(this.position.index===null||!l.isValidIndex(r))return;const a=new k(this,r,t);i.push(a)}),i}}s(R,"id","N"),s(R,"name","Knight"),s(R,"value");class D extends y{constructor(t,i){super(t,i);s(this,"maxFileDifference",1);s(this,"VALUE_GRID_PAWN",[0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,2,1,2,3,3,2,1,2,3,2,3,4,4,3,2,3,4,3,4,5,5,4,3,4,5,4,5,6,6,5,4,5,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8]);this.type=u.PAWN}get valueGrid(){return this.VALUE_GRID_PAWN}get promotionRank(){return this.isWhite?7:0}get startingRank(){return this.isWhite?1:6}get isAtStart(){return this.position.rank===this.startingRank}_generateMoves(t){let i=[];return i=this.generateMoveOneAheadMove(t,i),i=this.generateTwoAheadMove(t,i),i=this.generateAttackMoves(t,i),i}generatePromotionMoves(t,i,n){const r=n(1);if(!r)return[];const a=new k(this,r,t);a.isPromotion=!0,a.promotionPiece=u.QUEEN.id;const h=new k(this,r,t);h.isPromotion=!0,h.promotionPiece=u.KNIGHT.id;const d=new k(this,r,t);d.isPromotion=!0,d.promotionPiece=u.BISHOP.id;const C=new k(this,r,t);return C.isPromotion=!0,C.promotionPiece=u.ROOK.id,i.push(a),i.push(h),i.push(d),i.push(C),i}generateMoveOneAheadMove(t,i){const n=this.directions.forward(1);if(n===null)return i;const r=new k(this,n,t);return r.mustBeFree.push(n),r.canBeCapture=!1,r.isAttack=!1,i.push(r),i=this.generatePromotionMoves(t,i,this.directions.forward),i}generateAttackMoves(t,i){let n=[];return n=this.generatePromotionMoves(t,n,this.directions.forwardLeft),n=this.generatePromotionMoves(t,n,this.directions.forwardRight),this.appendMove(t,n,this.directions.forwardLeft(1)),this.appendMove(t,n,this.directions.forwardRight(1)),n=n.map(r=>(r.mustBeCapture=!0,r.canBeEnpassant=!0,r)),i=i.concat(n),i}generateTwoAheadMove(t,i){const n=this.directions.forward(1),r=this.directions.forward(2);if(!n||!r)return i;const a=new k(this,r,t);return a.hasToStartAtRank=this.startingRank,a.mustBeFree.push(n),a.mustBeFree.push(r),a.canBeCapture=!1,a.willCreateEnPassant=!0,a.isAttack=!1,a.enPassantPositionCreated=new l(this.directions.forward(1)),i.push(a),i}}s(D,"id","P"),s(D,"name","Pawn"),s(D,"value");class G extends y{constructor(t,i){super(t,i);s(this,"VALUE_GRID_QUEEN",[1,1,1,3,3,1,1,1,1,2,2,4,4,2,2,1,1,2,3,5,5,3,2,1,3,4,5,7,7,5,4,3,3,4,5,7,7,5,4,3,1,2,3,5,5,3,2,1,1,2,2,4,4,2,2,1,1,1,1,3,3,1,1,1]);this.maxFileDifference=8,this.type=u.QUEEN}get valueGrid(){return this.VALUE_GRID_QUEEN}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(G,"id","Q"),s(G,"name","Queen"),s(G,"value");class S extends y{constructor(t,i){super(t,i);s(this,"VALUE_GRID_ROOK",[5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,5,5,6,7,7,7,7,6,5,5,6,7,8,8,7,6,5,5,6,7,8,8,7,6,5,5,6,7,7,7,7,6,5,5,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5]);this.maxFileDifference=7,this.type=u.ROOK}get valueGrid(){return this.VALUE_GRID_ROOK}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(S,"id","R"),s(S,"name","Rook"),s(S,"value");class _{static generate(e,t,i){let n;switch(t){case u.KING.id:n=new B(e,i);break;case u.QUEEN.id:n=new G(e,i);break;case u.ROOK.id:n=new S(e,i);break;case u.BISHOP.id:n=new T(e,i);break;case u.KNIGHT.id:n=new R(e,i);break;case u.PAWN.id:n=new D(e,i);break;default:n=new E(e);break}return n}}class P{constructor(e="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"){s(this,"initialString");s(this,"board");s(this,"playerTurn");s(this,"castle");s(this,"enPassant");s(this,"halfMoveClock");s(this,"fullMoveClock");const t=e.split(" ");this.initialString=e,this.board=t[0],this.playerTurn=t[1],this.castle=t[2],this.enPassant=t[3],this.halfMoveClock=t[4],this.fullMoveClock=t[5]}static ParseFEN(e){const t=new P(e),i={};i.board=P.parseBoard(t);const n=P.parseCastleStateFEN(t),r=P.parseEnPassantFEN(t),a=P.parsePlayerTurnFEN(t),h=parseInt(t.halfMoveClock),d=parseInt(t.fullMoveClock);return i.state=new V(n,r,a,h,d),i}static parseBoard(e){const t=[],i=e.board.split("");let n=0;return i.forEach(r=>{if(r==="/")return;if(Y(r)){const h=parseFloat(r);for(let d=0;d<h;d++)t[n]=_.generate(n,u.EMPTY.id,w.Null),n++;return}const a=M(r)?w.White:w.Black;t[n]=_.generate(n,r.toLocaleUpperCase(),a),n++}),t}static parsePlayerTurnFEN(e){return new w(e.playerTurn.toLocaleUpperCase())}static parseCastleStateFEN(e){return e.castle}static parseEnPassantFEN(e){return e.enPassant==="-"?null:new l(e.enPassant)}static generateFEN(e,t=!1){const i=new P;return i.board=P.generateBoardFEN(e),i.playerTurn=P.generatePlayerTurnFEN(e),i.castle=P.generateCastleStateFEN(e),i.enPassant=P.generateEnPassantFEN(e),i.halfMoveClock=P.generateHalfMoveClockFEN(e),i.fullMoveClock=P.generateTurnNumberFEN(e),t?`${i.board} ${i.playerTurn}`:`${i.board} ${i.playerTurn} ${i.castle} ${i.enPassant} ${i.halfMoveClock} ${i.fullMoveClock}`}static generateBoardFEN(e){let t="",i=0;for(let n=0;n<64;n++){const r=e.board[n];r.type.id===u.EMPTY.id?i++:(i>0&&(t+=i,i=0),t+=r.isWhite?r.type.id:r.type.id.toLowerCase()),n%8===7&&(i>0&&(t+=i,i=0),n!==63&&(t+="/"))}return t}static generatePlayerTurnFEN(e){return e.playerTurn.colour.id}static generateCastleStateFEN(e){return e.state.castle}static generateEnPassantFEN(e){return e.state.enPassant?e.state.enPassant.an:"-"}static generateHalfMoveClockFEN(e){return e.state.halfMoveClock.toString()}static generateTurnNumberFEN(e){return e.state.fullMoveClock.toString()}}class Z{constructor(e="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",t,i){s(this,"FEN");s(this,"board",[]);s(this,"moveHistory");s(this,"currentEvaluation");s(this,"selectedPiece",null);s(this,"whitePlayer");s(this,"blackPlayer");s(this,"_playerTurn");s(this,"state");this.whitePlayer=t,this.blackPlayer=i;const n=P.ParseFEN(e);this.board=n.board,this.state=n.state,this.FEN=n.FEN,this._playerTurn=n.state.colour.isWhite?this.whitePlayer:this.blackPlayer,this.currentEvaluation=0,this.moveHistory=[]}get playerTurn(){return this._playerTurn}set playerTurn(e){e.colour.isWhite?this._playerTurn=this.whitePlayer:this._playerTurn=this.blackPlayer}get isWhitesMove(){return this.playerTurn.colour.isWhite}get isBlacksMove(){return this.playerTurn.colour.isBlack}isCheck(e){for(const t of this.board){if(t.isEmpty||t.isKing||t.colour.isEqual(e))continue;if(t.generateScope(this).some(r=>r.endPiece.isKing))return!0}return!1}selectPiece(e){return this.selectedPiece&&this.selectedPiece.deselect(),this.selectedPiece=this.getPieceAtIndex(e),this.selectedPiece&&this.selectedPiece.select(),this.selectedPiece}deselectPiece(){this.selectedPiece&&(this.selectedPiece.deselect(),this.selectedPiece=null)}getPieceAtIndex(e){return this.board[e]}getPieceAtPosition(e){try{return this.board[e.index]}catch(t){throw console.log(e,t),new Error("Invalid position")}}placePieceAtIndex(e,t){e.position=t,this.board[t]=e}placePieceAtPosition(e,t){t.index!==null&&this.placePieceAtIndex(e,t.index)}destroyPieceAtIndex(e){return this.board[e]=new E(e)}destroyPieceAtPosition(e){return e.index===null?null:this.destroyPieceAtIndex(e.index)}changePlayer(){this.state.colour=this.playerTurn.colour,this.playerTurn=this.playerTurn.colour.isWhite?this.blackPlayer:this.whitePlayer}addMoveHistory(e){this.moveHistory.push(e)}removeMoveFromHistory(e){const t=this.moveHistory.indexOf(e);t>-1&&this.moveHistory.splice(t,1)}getMoves(e){let t=[];return this.board.forEach(i=>{if(this.getMovesFilter(e,i)){t=t.concat(i.generateMoves(this));return}},this),t}getScope(e){let t=[];return this.board.forEach(i=>{if(this.getMovesFilter(e,i)){t=t.concat(i.generateScope(this));return}},this),t}getMovesFilter(e,t){return e?!(e.colour&&!e.colour.isEqual(t.colour)||e.piece&&e.piece!==t.type.id||e.pieces&&!e.pieces.includes(t.type.id)||e.exludedPieces&&e.exludedPieces.includes(t.type.id)):!0}_destroyPositions(e){e.forEach(t=>{t.index!==null&&(this.board[t.index]=new E(t.index))})}_handleEnPassant(e){if(e.willCreateEnPassant){this.state.enPassant=e.enPassantPositionCreated;return}this.state.enPassant=null}}class ${constructor(e,t){s(this,"_isHuman");s(this,"_colour");s(this,"_isPlayerTurn",!1);this._isHuman=t,this._colour=new w(e)}get isHuman(){return this._isHuman}set isHuman(e){this._isHuman=e}get isCpu(){return!this._isHuman}set isCpu(e){this._isHuman=!e}get colour(){return this._colour}}const x=class x{static simple(e){let t=0;const i=P.generateFEN(e,!0),n=g.getEvaluation(i);if(n.result===!0)return n.evaluation;for(const r of e.board)r.isEmpty||(r.colour.isWhite?(t+=x.positionalValue(r),t+=x.pieceValue(r)):(t-=x.positionalValue(r),t-=x.pieceValue(r)));return t+=this.mateValue(e),g.cacheEvaluation(i,t),t}static positionalValue(e){let t=0;return t+=e.positionalValue(e.position),t*x.positionMultiplyer}static pieceValue(e){return e.type.value}static mateValue(e){let t=!1;return e.isCheck(e.playerTurn.colour)&&(t=e.getMoves({colour:e.playerTurn.colour}).length===0),t?e.playerTurn.colour.isWhite?-1/0:1/0:0}};s(x,"positionMultiplyer",.1);let F=x;const A=class A{constructor(e){s(this,"alpha");s(this,"beta");s(this,"numberOfPositions",0);s(this,"game");s(this,"bestMove",null);s(this,"moves",[]);s(this,"iterativeDeepeningCurrentDepth",1);this.game=e,this.alpha=-1/0,this.beta=1/0}search(){const e=this.iterativeDeepening(this.game);return e===void 0?null:(this.bestMove=e,e)}alphaBeta(e,t,i,n=[]){if(t===0)return this.numberOfPositions++,F.simple(e);const r=n.length>0?n:e.getMoves({colour:i?w.White:w.Black}).sort((h,d)=>d.simpleEvaluation-h.simpleEvaluation);let a;if(i){a=-1/0;for(const h of r){h.do(!1);const d=this.alphaBeta(e,t-1,!1);if(a=Math.max(d,a),h.searchCalculatedValue=d,h.undo(),t===this.iterativeDeepeningCurrentDepth&&console.log(h.algebraicNotation,this.alpha,this.beta),a>this.beta)break;this.alpha=Math.max(this.alpha,a)}}else{a=1/0;for(const h of r){h.do(!1),t===this.iterativeDeepeningCurrentDepth&&console.log(h.algebraicNotation,this.alpha,this.beta);const d=this.alphaBeta(e,t-1,!0);if(a=Math.min(d,a),h.searchCalculatedValue=d,h.undo(),a<this.alpha)break;this.beta=Math.min(this.beta,a)}}return this.moves=r,a}checkAllTakes(e,t){let i=F.simple(e);const n=t?w.White:w.Black;if(t){if(i>this.beta)return i;this.alpha=Math.max(this.alpha,i)}else{if(i<this.alpha)return i;this.beta=Math.min(this.beta,i)}const r=e.getMoves({colour:n}).filter(a=>!a.endPiece.isEmpty&&!a.endPiece.colour.isEqual(n)).sort((a,h)=>h.simpleEvaluation-a.simpleEvaluation);if(r.length===0)return i;if(t)for(const a of r){a.do(!1);const h=this.checkAllTakes(e,!1);if(i=Math.max(h,i),a.searchCalculatedValue=h,a.undo(),i>this.beta)break;this.alpha=Math.max(this.alpha,i)}else for(const a of r){a.do(!1);const h=this.checkAllTakes(e,!0);if(i=Math.min(h,i),a.searchCalculatedValue=h,a.undo(),i<this.alpha)break;this.beta=Math.min(this.beta,i)}return i}iterativeDeepening(e,t=A.iterativeDeepeningMaxDepth){console.time(`IterativeDeepending total for depth ${t}`);for(let i=1;i<=t;i++)this.iterativeDeepeningCurrentDepth=i,this.alpha=-1/0,this.beta=1/0,console.log("=================================================="),console.log("Starting best move calculation for",e.playerTurn.colour.name,"at depth",i),console.time(`iterativeDeepending at depth ${i}`),this.alphaBeta(e,i,e.playerTurn.colour.isWhite,this.moves),this.moves=this.moves.toSorted((n,r)=>e.playerTurn.colour.isWhite?r.searchCalculatedValue-n.searchCalculatedValue:n.searchCalculatedValue-r.searchCalculatedValue),g.clearEvaluationCache(),this.bestMove=this.moves[0],console.log("Returned move",this.bestMove.algebraicNotation,"for value",this.bestMove.searchCalculatedValue),console.timeEnd(`iterativeDeepending at depth ${i}`);return console.timeEnd(`IterativeDeepending total for depth ${t}`),console.log("Number of positions evaluated:",this.numberOfPositions),this.bestMove=this.moves[0],this.bestMove}};s(A,"depth",3),s(A,"iterativeDeepeningMaxDepth",4);let O=A;self.onmessage=o=>{if(!o.data)return;const e=new Z(o.data,new $("W",!1),new $("B",!1)),t=new O(e).search();postMessage(t)}})();
