var _=Object.defineProperty;var ee=(x,u,I)=>u in x?_(x,u,{enumerable:!0,configurable:!0,writable:!0,value:I}):x[u]=I;var s=(x,u,I)=>(ee(x,typeof u!="symbol"?u+"":u,I),I);(function(){"use strict";class x{constructor(e,t,i){s(this,"name");s(this,"id");s(this,"value");this.name=e,this.id=t,this.value=i}}const u={PAWN:new x("Pawn","P",1),KNIGHT:new x("Knight","N",3),KING:new x("King","K",0),QUEEN:new x("Queen","Q",9),ROOK:new x("Rook","R",5),BISHOP:new x("Bishop","B",3),EMPTY:new x("Empty","",0),NULL:new x("Null","-",-1)};function I(a){return a===a.toUpperCase()}function Y(a){return/^-?\d+$/.test(a)}let N;const j=new Uint8Array(16);function J(){if(!N&&(N=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!N))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return N(j)}const P=[];for(let a=0;a<256;++a)P.push((a+256).toString(16).slice(1));function X(a,e=0){return P[a[e+0]]+P[a[e+1]]+P[a[e+2]]+P[a[e+3]]+"-"+P[a[e+4]]+P[a[e+5]]+"-"+P[a[e+6]]+P[a[e+7]]+"-"+P[a[e+8]]+P[a[e+9]]+"-"+P[a[e+10]]+P[a[e+11]]+P[a[e+12]]+P[a[e+13]]+P[a[e+14]]+P[a[e+15]]}var $={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function Q(a,e,t){if($.randomUUID&&!e&&!a)return $.randomUUID();a=a||{};const i=a.random||(a.rng||J)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,e){t=t||0;for(let n=0;n<16;++n)e[t+n]=i[n];return e}return X(i)}class m{constructor(e,t,i,n,r){s(this,"castle");s(this,"enPassant");s(this,"colour");s(this,"halfMoveClock",0);s(this,"fullMoveClock",1);s(this,"id");s(this,"isCheckMate",!1);s(this,"isStaleMate",!1);this.castle=e,this.enPassant=t,this.colour=i,this.halfMoveClock=n,this.fullMoveClock=r,this.id=Q()}copy(e=!1){if(this.enPassant===null){const i=new m(this.castle,null,this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(i.id=this.id),i}const t=new m(this.castle,this.enPassant.copy(),this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(t.id=this.id),t}}const h=class h{constructor(e){s(this,"id");this.id=e}get isWhite(){return this.id===h.whiteId}get isBlack(){return this.id===h.blackId}get isNull(){return this.id===h.nullId}get name(){return this.isBlack?h.blackName:h.whiteName}changePlayer(){return this.id===h.nullId?h.Null:(this.id=this.isBlack?h.whiteId:h.blackId,this)}isEqual(e){return h.areSameColour(this,e)}get opposite(){return this.id===h.nullId?h.Null:this.isBlack?new h(h.whiteId):new h(h.blackId)}copy(){return new h(this.id)}static get Black(){return h._black}static get White(){return h._white}static get Null(){return h._null}static areSameColour(e,t){return e.id===t.id}static areDifferentColourAndNotNull(e,t){return e.isNull||t.isNull?!1:e.id!==t.id}};s(h,"whiteId","W"),s(h,"blackId","B"),s(h,"blackName","Black"),s(h,"whiteName","White"),s(h,"nullId",""),s(h,"_black",new h("B")),s(h,"_white",new h("W")),s(h,"_null",new h(""));let g=h;const f=class f{constructor(e){s(this,"_index",f._nullIndex);e!==null&&(this._index=e)}get neighbours(){return this.index===null?{north:null,south:null,east:null,west:null,northEast:null,northWest:null,southEast:null,southWest:null}:{north:new f(this.index-8),south:new f(this.index+8),east:new f(this.index+1),west:new f(this.index-1),northEast:new f(this.index-7),northWest:new f(this.index-9),southEast:new f(this.index+9),southWest:new f(this.index+7)}}get index(){if(this._index===null)throw new Error("Position index is null");return this._index}set index(e){this._index=e}get an(){return f.indexToAn(this.index)}set an(e){this._index=f.anToIndex(e)}get rank(){const e=f.getRankOfIndex(this._index);if(this._index===null||e===null)throw new Error("Position rank is null");return e}set rank(e){this._index=f.rankFileToIndex(e,this.file)}get file(){const e=f.getFileOfIndex(this._index);if(this._index===null||e===null)throw new Error("Position file is null");return e}set file(e){this._index=f.rankFileToIndex(this.rank,e)}static ParseAn(e){const t=f.anToIndex(e);return t===null?null:new f(t)}isEqual(e){return this.index===e.index}copy(){return new f(this.index)}static fileDifference(e,t){return e.file===null||t.file===null?1/0:Math.abs(e.file-t.file)}static indexToAn(e){if(e===null)return"-";const t="abcdefgh",i=e%8,n=8-Math.floor(e/8);return t[i]+n}static anToIndex(e){const i="abcdefgh".indexOf(e[0]),n=8-Number(e[1]);return i===-1||n===-1?null:n+i*8}static rankFileToIndex(e,t){return t===null||e===null?null:e+(7-t)*8}static getRankOfIndex(e){return e===null?null:7-Math.floor(e/8)}static getFileOfIndex(e){return e===null?null:e%8}static isValidIndex(e){return e===null?!1:e>=0&&e<=63}};s(f,"_nullIndex",null);let o=f;class w{static getMoves(e,t){var i;try{const n=(i=this.moveCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static cacheMoves(e,t,i){this.moveCache[e]={[t]:i}}static clearCache(){console.log("Clearing cache"),this.moveCache={},this.evalCache={},this.scopeCache={}}static clearEvaluationCache(){this.evalCache={}}static cacheScope(e,t,i){this.scopeCache[e]={[t]:i}}static getScope(e,t){var i;try{const n=(i=this.scopeCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static getEvaluation(e){try{const t=this.evalCache[e];return t!==void 0?{result:!0,evaluation:t}:{result:!1,evaluation:0}}catch{return{result:!1,evaluation:0}}}static cacheEvaluation(e,t){this.evalCache[e]=t}}s(w,"moveCache",{}),s(w,"scopeCache",{}),s(w,"evalCache",{});class q{static validateScope(e,t){return t.skipValidate?!0:!(!t.nullValidate||!this.position(t)||!this.cantHaveMoved(t)||!this.freePositions(e,t)||!this.pieceAtIndexesCantHaveMoved(t)||!this.pieceInPosition(t)||!this.isACapture(e,t)||!this.isAPromotion(t)||!this.castle(e,t))}static validate(e,t){return this.validateScope(e,t)&&this.willPutPlayerInCheck(e,t)&&this.indexesCantBeUnderAttack(t)}static castle(e,t){return t.isCastleMove?!!e.state.castle:!0}static willPutPlayerInCheck(e,t){t.do(!1);const i=e.isInCheck(t.piece.colour);return t.undo(),!i}static isAPromotion(e){if(e.piece.isPawn){const t=e.piece;return e.isPromotion&&e.end.rank===t.promotionRank||!e.isPromotion&&e.end.rank!==t.promotionRank}return!0}static position(e){return!(e.hasToStartAtRank&&e.start.rank!==e.hasToStartAtRank||o.fileDifference(e.start,e.end)>e.piece.maxFileDifference)}static cantHaveMoved(e){return!(e.piece.hasMoved&&e.pieceCantHaveMoved)}static isACapture(e,t){if(t.endPiece.colour.isEqual(t.piece.colour))return!1;if(!t.mustBeCapture||t.isCapture)return!0;if(e.state.enPassant!==null&&t.canBeEnpassant&&t.piece.isPawn&&(t.isEnpassantTake=e.state.enPassant.isEqual(t.end),t.isEnpassantTake)){if(e.state.enPassant.neighbours.north===null||e.state.enPassant.neighbours.south==null)return!1;t.willDestroy.push(e.state.enPassant.neighbours.north,e.state.enPassant.neighbours.south)}return t.isEnpassantTake}static freePositions(e,t){return t.mustBeFree.every(i=>e.getPieceAtPosition(i).isEmpty)}static pieceInPosition(e){return e.mustHavePieceAtIndex.piece&&e.mustHavePieceAtIndex.index?e.game.getPieceAtIndex(e.mustHavePieceAtIndex.index).isOfType(e.mustHavePieceAtIndex.piece):!0}static pieceAtIndexesCantHaveMoved(e){return e.pieceAtIndexesCantHaveMoved.every(t=>!e.game.getPieceAtIndex(t).hasMoved)}static indexesCantBeUnderAttack(e){const t=e.game.getScope({colour:e.piece.colour.opposite});return e.indexesCantBeUnderAttack.every(i=>!t.some(n=>n.end.index===i))}}class M{constructor(e,t,i){s(this,"start");s(this,"end");s(this,"piece");s(this,"willCreateEnPassant",!1);s(this,"willDestroy",[]);s(this,"isAttack",!0);s(this,"isEnpassantTake",!1);s(this,"isCastleMove",!1);s(this,"enPassantPositionCreated",null);s(this,"canBeEnpassant",!1);s(this,"mustBeFree",[]);s(this,"mustBeCapture",!1);s(this,"canBeCapture",!0);s(this,"hasToStartAtRank",null);s(this,"skipValidate",!1);s(this,"changePlayerAfterMove",!0);s(this,"extraMoves",[]);s(this,"value",null);s(this,"endPiece");s(this,"pieceCantHaveMoved",!1);s(this,"destoryedPieces",[]);s(this,"stateBefore");s(this,"castleChange","");s(this,"game");s(this,"isPromotion",!1);s(this,"promotionPiece",u.EMPTY.id);s(this,"hasMovedBefore");s(this,"stateId");s(this,"valueCalculated",!1);s(this,"searchCalculatedValue",0);s(this,"mustHavePieceAtIndex",{});s(this,"pieceAtIndexesCantHaveMoved",[]);s(this,"indexesCantBeUnderAttack",[]);this.start=new o(e.position.index),this.end=new o(t),this.piece=e,this.hasMovedBefore=this.piece.hasMoved,this.game=i,this.endPiece=i.getPieceAtPosition(this.end),this.stateBefore=i.state.copy(!0),this.stateId=i.state.id}get stateAfter(){return this.constructStateAfter()}get isCheck(){return this.endPiece.isKing&&g.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get simpleEvaluation(){return this.endPiece.type.value+this.piece.valueGrid[this.end.index]}get isCapture(){return g.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get nullValidate(){return!!this.endPiece}destroyPositions(){this.willDestroy.forEach(e=>{this.destoryedPieces.push(this.game.board[e.index]),this.game.destroyPieceAtPosition(e)})}undoDestroyPositions(){for(const e of this.destoryedPieces)this.game.placePieceAtPosition(e,e.position);this.destoryedPieces=[]}constructStateAfter(){const e=this.stateBefore.copy();return this.castleChange!==""&&this.castleChange.split("").forEach(t=>{e.castle=e.castle.replace(t,"")}),this.enPassantPositionCreated!==null?e.enPassant=this.enPassantPositionCreated:e.enPassant=null,(this.isCapture||this.piece.isPawn)&&(e.halfMoveClock=0),e.halfMoveClock++,this.piece.colour.isWhite&&e.fullMoveClock++,this.changePlayerAfterMove&&(e.colour=e.colour.opposite),e}doExtraMoves(e=!0){this.extraMoves.forEach(t=>{t.do(e)})}undoExtraMoves(){this.extraMoves.forEach(e=>{e.undo()})}handlePromotion(){if(this.isPromotion){const e=this.end.index;this.game.destroyPieceAtIndex(e);const t=this.piece.colour,i=F.generate(e,this.promotionPiece,t);this.game.placePieceAtPosition(i,this.end)}}undoPromotion(){this.isPromotion&&(this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.start))}validate(e){return q.validate(e,this)}validateScope(e){return q.validateScope(e,this)}do(e=!0){this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.end),this.game.state=this.stateAfter,this.destroyPositions(),this.handlePromotion(),this.doExtraMoves(e),this.piece.hasMoved=!0,e&&(this.game.moveHistory.push(this),w.clearCache())}undo(){this.game.placePieceAtPosition(this.piece,this.start),this.game.placePieceAtPosition(this.endPiece,this.end),this.game.state=this.stateBefore,this.undoDestroyPositions(),this.undoPromotion(),this.undoExtraMoves(),this.piece.hasMoved=this.hasMovedBefore}get algebraicNotation(){const e=this.piece.type.id,t=this.end.an,i=this.isCapture?"x":"",n=this.isPromotion?`=${this.promotionPiece}`:"",r=this.isCastleMove?"O-O":"";return`${e}${i}${t}${n}${r}`}}class E{constructor(e,t){s(this,"type");s(this,"colour");s(this,"selected");s(this,"hasMoved",!1);s(this,"maxFileDifference",0);s(this,"_position");s(this,"_moves",[]);s(this,"_scope",[]);s(this,"id");this._position=new o(e),this.colour=t,this.selected=!1,this.type=u.NULL,this.id=Q()}get valueGrid(){return new Array(64).fill(0)}set position(e){this._position=e}get position(){return this._position}positionalValue(e){return e.index===null?0:this.colour.isBlack?this.valueGrid[63-e.index]:this.valueGrid[e.index]}get directions(){return this.colour.isBlack?{forward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},left:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},right:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},forwardLeft:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},forwardRight:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backwardLeft:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backwardRight:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)}}:{forward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},left:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},right:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},forwardLeft:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},forwardRight:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backwardLeft:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)},backwardRight:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!o.isValidIndex(t)?null:new o(t)}}}get moves(){return this._moves}get scope(){return this._scope}get isBlack(){return this.colour.isBlack}get isWhite(){return this.colour.isWhite}get isEmpty(){return this.type.id===u.EMPTY.id}get isKing(){return this.type.id===u.KING.id}get isPawn(){return this.type.id===u.PAWN.id}get isBishop(){return this.type.id===u.BISHOP.id}get isKnight(){return this.type.id===u.KNIGHT.id}get isRook(){return this.type.id===u.ROOK.id}get isQueen(){return this.type.id===u.QUEEN.id}generateMoves(e){const t=w.getMoves(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validate(e));return w.cacheMoves(this.id,e.state.id,i),i}_generateMoves(e){return console.log(this.type.name,e.state.id),[]}generateScope(e){const t=w.getScope(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validateScope(e));return w.cacheScope(this.id,e.state.id,i),i}select(){this.selected=!0}deselect(){this.selected=!1}directionMoveGenerator(e,t,i){var n;for(let r=1;r<=8;r++){const l=t(r);if(!l)continue;const c=new M(this,l.index,i);for(let p=1;p<=r-1;p++){if(!t(p))continue;const k=(n=t(p))==null?void 0:n.index;k!=null&&c.mustBeFree.push(new o(k))}const d=c.mustBeFree.length?c.mustBeFree[c.mustBeFree.length-1]:this.position;if(o.fileDifference(l,d)>1)return;e.push(c)}}appendMove(e,t,i){if(i!==null){const n=new M(this,i.index,e);t.push(n)}}isOfType(e){return this.type.id===e}}class T extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_BISHOP",[0,0,0,0,0,0,0,1,1,2,0,0,0,0,2,1,2,3,3,3,3,3,3,2,2,3,4,4,4,4,3,2,3,5,6,5,5,6,5,3,5,6,6,4,4,6,6,5,6,6,4,4,4,4,6,6,0,0,0,0,0,0,0,0]);this.maxFileDifference=8,this.type=u.BISHOP}get valueGrid(){return this.VALUE_GRID_BISHOP}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),i}}s(T,"id","B"),s(T,"name","Bishop"),s(T,"value");class b extends E{constructor(e){super(e,g.Null),this.type=u.EMPTY}}s(b,"id",""),s(b,"name","Empty"),s(b,"value",0);class R extends E{constructor(t,i){super(t,i);s(this,"KING_VALUE_GRID",[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,2,2,2,2,1,0,0,1,2,4,4,2,1,0,0,1,2,4,4,2,1,0,0,1,2,2,2,2,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0]);this.maxFileDifference=5,this.type=u.KING}get valueGrid(){return this.KING_VALUE_GRID}castleMoves(t){let i,n,r,l,c,d,p,k,C,W,L;this.isBlack?(i=2,n=3,r=0,k=[1,2,3],W=[3,4],C="q",l=6,c=5,d=7,p=[5,6],L=[4,5],C="k"):(i=58,n=59,r=56,k=[57,58,59],W=[59,60],C="Q",l=62,c=61,d=63,p=[61,62],L=[60,61],C="K");const Z=this.createCastleMove(i,t,r,n,k,W,C),z=this.createCastleMove(l,t,d,c,p,L,C);return[Z,z]}createCastleMove(t,i,n,r,l,c,d){const p=new M(this,t,i);p.isCastleMove=!0,p.isAttack=!1,p.changePlayerAfterMove=!1,p.mustHavePieceAtIndex={piece:"R",index:n},p.mustBeFree=l.map(C=>new o(C)),p.pieceAtIndexesCantHaveMoved=[n,this.position.index],p.castleChange=d,p.indexesCantBeUnderAttack=[this.position.index].concat(l),p.indexesCantBeUnderAttack=c;const k=new M(i.getPieceAtPosition(new o(n)),r,i);return k.skipValidate=!0,p.extraMoves.push(k),p}_generateMoves(t){let i=[];return this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.backward(1)),this.appendMove(t,i,this.directions.left(1)),this.appendMove(t,i,this.directions.right(1)),this.appendMove(t,i,this.directions.backwardLeft(1)),this.appendMove(t,i,this.directions.backwardRight(1)),this.appendMove(t,i,this.directions.forwardLeft(1)),this.appendMove(t,i,this.directions.forwardRight(1)),i.forEach(n=>{n.piece.isWhite&&(n.castleChange="KQ"),n.piece.isBlack&&(n.castleChange="kq")}),i=i.concat(this.castleMoves(t)),i}}s(R,"id","K"),s(R,"name","King"),s(R,"value");class D extends E{constructor(t,i){super(t,i);s(this,"maxFileDifference",2);s(this,"VALUE_GRID_KINGHT",[0,1,1,1,1,1,1,0,1,2,2,2,2,2,2,1,1,5,7,6,6,7,0,1,2,4,8,7,7,8,0,2,1,3,6,5,5,6,3,1,1,2,4,3,3,4,2,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0]);this.type=u.KNIGHT}get valueGrid(){return this.VALUE_GRID_KINGHT}get knightEndPositionShift(){return[10,-10,17,-17,15,-15,6,-6]}_generateMoves(t){const i=[];return this.knightEndPositionShift.forEach(n=>{const r=this.position.index+n;if(this.position.index===null||!o.isValidIndex(r))return;const l=new M(this,r,t);i.push(l)}),i}}s(D,"id","N"),s(D,"name","Knight"),s(D,"value");class V extends E{constructor(t,i){super(t,i);s(this,"maxFileDifference",1);s(this,"VALUE_GRID_PAWN",[0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,2,1,2,3,3,2,1,2,3,2,3,4,4,3,2,3,4,3,4,5,5,4,3,4,5,4,5,6,6,5,4,5,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8]);this.type=u.PAWN}get valueGrid(){return this.VALUE_GRID_PAWN}get promotionRank(){return this.isWhite?7:0}get startingRank(){return this.isWhite?1:6}get isAtStart(){return this.position.rank===this.startingRank}_generateMoves(t){let i=[];return i=this.generateMoveOneAheadMove(t,i),i=this.generateTwoAheadMove(t,i),i=this.generateAttackMoves(t,i),i}generatePromotionMoves(t,i,n){const r=n(1);if(!r)return[];const l=new M(this,r.index,t);l.isPromotion=!0,l.promotionPiece=u.QUEEN.id;const c=new M(this,r.index,t);c.isPromotion=!0,c.promotionPiece=u.KNIGHT.id;const d=new M(this,r.index,t);d.isPromotion=!0,d.promotionPiece=u.BISHOP.id;const p=new M(this,r.index,t);return p.isPromotion=!0,p.promotionPiece=u.ROOK.id,i.push(l),i.push(c),i.push(d),i.push(p),i}generateMoveOneAheadMove(t,i){const n=this.directions.forward(1);if(n===null)return i;const r=new M(this,n.index,t);return r.mustBeFree.push(n),r.canBeCapture=!1,r.isAttack=!1,i.push(r),i=this.generatePromotionMoves(t,i,this.directions.forward),i}generateAttackMoves(t,i){let n=[];return n=this.generatePromotionMoves(t,n,this.directions.forwardLeft),n=this.generatePromotionMoves(t,n,this.directions.forwardRight),this.appendMove(t,n,this.directions.forwardLeft(1)),this.appendMove(t,n,this.directions.forwardRight(1)),n=n.map(r=>(r.mustBeCapture=!0,r.canBeEnpassant=!0,r)),i=i.concat(n),i}generateTwoAheadMove(t,i){const n=this.directions.forward(1),r=this.directions.forward(2);if(!n||!r)return i;const l=new M(this,r.index,t);l.hasToStartAtRank=this.startingRank,l.mustBeFree.push(n),l.mustBeFree.push(r),l.canBeCapture=!1,l.willCreateEnPassant=!0,l.isAttack=!1;const c=this.directions.forward(1);return c!==null&&(l.enPassantPositionCreated=new o(c.index)),i.push(l),i}}s(V,"id","P"),s(V,"name","Pawn"),s(V,"value");class G extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_QUEEN",[1,1,1,3,3,1,1,1,1,2,2,4,4,2,2,1,1,2,3,5,5,3,2,1,3,4,5,7,7,5,4,3,3,4,5,7,7,5,4,3,1,2,3,5,5,3,2,1,1,2,2,4,4,2,2,1,1,1,1,3,3,1,1,1]);this.maxFileDifference=8,this.type=u.QUEEN}get valueGrid(){return this.VALUE_GRID_QUEEN}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(G,"id","Q"),s(G,"name","Queen"),s(G,"value");class H extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_ROOK",[5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,5,5,6,7,7,7,7,6,5,5,6,7,8,8,7,6,5,5,6,7,8,8,7,6,5,5,6,7,7,7,7,6,5,5,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5]);this.maxFileDifference=7,this.type=u.ROOK}get valueGrid(){return this.VALUE_GRID_ROOK}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(H,"id","R"),s(H,"name","Rook"),s(H,"value");class F{static generate(e,t,i){let n;switch(t){case u.KING.id:n=new R(e,i);break;case u.QUEEN.id:n=new G(e,i);break;case u.ROOK.id:n=new H(e,i);break;case u.BISHOP.id:n=new T(e,i);break;case u.KNIGHT.id:n=new D(e,i);break;case u.PAWN.id:n=new V(e,i);break;default:n=new b(e);break}return n}}class v{constructor(e="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"){s(this,"initialString");s(this,"board");s(this,"playerTurn");s(this,"castle");s(this,"enPassant");s(this,"halfMoveClock");s(this,"fullMoveClock");const t=e.split(" ");this.initialString=e,this.board=t[0],this.playerTurn=t[1],this.castle=t[2],this.enPassant=t[3],this.halfMoveClock=t[4],this.fullMoveClock=t[5]}static ParseFEN(e){const t=new v(e),i={};i.board=v.parseBoard(t);const n=v.parseCastleStateFEN(t),r=v.parseEnPassantFEN(t),l=v.parsePlayerTurnFEN(t),c=parseInt(t.halfMoveClock),d=parseInt(t.fullMoveClock);return i.state=new m(n,r,l,c,d),i}static parseBoard(e){const t=[],i=e.board.split("");let n=0;return i.forEach(r=>{if(r==="/")return;if(Y(r)){const c=parseFloat(r);for(let d=0;d<c;d++)t[n]=F.generate(n,u.EMPTY.id,g.Null),n++;return}const l=I(r)?g.White:g.Black;t[n]=F.generate(n,r.toLocaleUpperCase(),l),n++}),t}static parsePlayerTurnFEN(e){return new g(e.playerTurn.toLocaleUpperCase())}static parseCastleStateFEN(e){return e.castle}static parseEnPassantFEN(e){return e.enPassant==="-"?null:o.ParseAn(e.enPassant)}static generateFEN(e,t=!1){const i=new v;return i.board=v.generateBoardFEN(e),i.playerTurn=v.generatePlayerTurnFEN(e),i.castle=v.generateCastleStateFEN(e),i.enPassant=v.generateEnPassantFEN(e),i.halfMoveClock=v.generateHalfMoveClockFEN(e),i.fullMoveClock=v.generateTurnNumberFEN(e),t?`${i.board} ${i.playerTurn}`:`${i.board} ${i.playerTurn} ${i.castle} ${i.enPassant} ${i.halfMoveClock} ${i.fullMoveClock}`}static generateBoardFEN(e){let t="",i=0;for(let n=0;n<64;n++){const r=e.board[n];r.type.id===u.EMPTY.id?i++:(i>0&&(t+=i,i=0),t+=r.isWhite?r.type.id:r.type.id.toLowerCase()),n%8===7&&(i>0&&(t+=i,i=0),n!==63&&(t+="/"))}return t}static generatePlayerTurnFEN(e){return e.playerTurn.colour.id}static generateCastleStateFEN(e){return e.state.castle}static generateEnPassantFEN(e){return e.state.enPassant?e.state.enPassant.an:"-"}static generateHalfMoveClockFEN(e){return e.state.halfMoveClock.toString()}static generateTurnNumberFEN(e){return e.state.fullMoveClock.toString()}}class S{constructor(e,t){s(this,"_isHuman");s(this,"_colour");s(this,"_isPlayerTurn",!1);this._isHuman=t,this._colour=new g(e)}get isHuman(){return this._isHuman}set isHuman(e){this._isHuman=e}get isCpu(){return!this._isHuman}set isCpu(e){this._isHuman=!e}get colour(){return this._colour}}const A=class A{constructor(e=A.initalBoardFEN,t,i){s(this,"FEN");s(this,"board",[]);s(this,"moveHistory");s(this,"currentEvaluation");s(this,"selectedPiece",null);s(this,"whitePlayer");s(this,"blackPlayer");s(this,"state");this.whitePlayer=t,this.blackPlayer=i;const n=v.ParseFEN(e);this.board=n.board,this.state=n.state,this.FEN=n.FEN,this.currentEvaluation=0,this.moveHistory=[]}get playerTurn(){return this.state.colour.isWhite?this.whitePlayer:this.blackPlayer}get isWhitesMove(){return this.playerTurn.colour.isWhite}get isBlacksMove(){return this.playerTurn.colour.isBlack}resetBoard(e=!0,t=!1){this.whitePlayer=new S("W",e),this.blackPlayer=new S("B",t);const i=v.ParseFEN(A.initalBoardFEN);this.board=i.board,this.state=i.state,this.FEN=i.FEN,this.currentEvaluation=0,this.moveHistory=[]}isInCheck(e){for(const t of this.board){if(t.isEmpty||t.isKing||t.colour.isEqual(e))continue;const n=t.generateScope(this).some(r=>r.endPiece.isKing);if(n===!0)return n}return!1}selectPiece(e){return this.selectedPiece&&this.selectedPiece.deselect(),this.selectedPiece=this.getPieceAtIndex(e),this.selectedPiece&&this.selectedPiece.select(),this.selectedPiece}deselectPiece(){this.selectedPiece&&(this.selectedPiece.deselect(),this.selectedPiece=null)}getPieceAtIndex(e){return this.board[e]}getPieceAtPosition(e){try{return this.board[e.index]}catch(t){throw console.log(e,t),new Error("Invalid position")}}placePieceAtIndex(e,t){e.position=new o(t),this.board[t]=e}placePieceAtPosition(e,t){t.index!==null&&this.placePieceAtIndex(e,t.index)}destroyPieceAtIndex(e){return this.board[e]=new b(e)}destroyPieceAtPosition(e){return this.destroyPieceAtIndex(e.index)}changePlayer(){this.state.colour=this.state.colour.opposite}addMoveHistory(e){this.moveHistory.push(e)}removeMoveFromHistory(e){const t=this.moveHistory.indexOf(e);t>-1&&this.moveHistory.splice(t,1)}getMoves(e){let t=[];return this.board.forEach(i=>{if(this.filterPieces(e,i)){t=t.concat(i.generateMoves(this));return}},this),t}getScope(e){let t=[];return this.board.forEach(i=>{if(this.filterPieces(e,i)){t=t.concat(i.generateScope(this));return}},this),t}filterPieces(e,t){return e?!(e.colour&&!e.colour.isEqual(t.colour)||e.piece&&e.piece!==t.type.id||e.pieces&&!e.pieces.includes(t.type.id)||e.exludedPieces&&e.exludedPieces.includes(t.type.id)):!0}getPieces(e){const t=[];return this.board.forEach(i=>{this.filterPieces(e,i)&&t.push(i)},this),t}_destroyPositions(e){e.forEach(t=>{t.index!==null&&(this.board[t.index]=new b(t.index))})}_handleEnPassant(e){if(e.willCreateEnPassant){this.state.enPassant=e.enPassantPositionCreated;return}this.state.enPassant=null}};s(A,"initalBoardFEN","rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");let U=A;const y=class y{static simple(e){let t=0;const i=v.generateFEN(e,!0),n=w.getEvaluation(i);if(n.result===!0)return n.evaluation;for(const r of e.board)r.isEmpty||(r.colour.isWhite?(t+=y.positionalValue(r),t+=y.pieceValue(r)):(t-=y.positionalValue(r),t-=y.pieceValue(r)));return t+=this.mateValue(e),w.cacheEvaluation(i,t),t}static positionalValue(e){let t=0;return t+=e.positionalValue(e.position),t*y.positionMultiplyer}static pieceValue(e){return e.type.value}static mateValue(e){return y.isCheckMate(e)?e.playerTurn.colour.isWhite?-1/0:1/0:0}static isCheckMate(e){let t=!1;return e.isInCheck(e.playerTurn.colour)&&(t=e.getMoves({colour:e.playerTurn.colour}).length===0),t}};s(y,"positionMultiplyer",.1);let O=y;const B=class B{constructor(e,t=B.maxDepth){s(this,"iterativeDeepeningMaxDepth");s(this,"alpha");s(this,"beta");s(this,"numberOfPositions",0);s(this,"game");s(this,"bestMove",null);s(this,"moves",[]);s(this,"iterativeDeepeningCurrentDepth",1);this.game=e,this.iterativeDeepeningMaxDepth=t,this.alpha=-1/0,this.beta=1/0}search(){const e=this.iterativeDeepening(this.game);return e===void 0?null:(this.bestMove=e,e)}alphaBeta(e,t,i,n=[]){if(t===0)return this.numberOfPositions++,O.simple(e);const r=n.length>0?n:e.getMoves({colour:i?g.White:g.Black}).sort((c,d)=>d.simpleEvaluation-c.simpleEvaluation);let l;if(i){l=-1/0;for(const c of r){c.do(!1);const d=this.alphaBeta(e,t-1,!1);if(l=Math.max(d,l),c.searchCalculatedValue=d,c.undo(),t===this.iterativeDeepeningCurrentDepth&&console.log(c.algebraicNotation,this.alpha,this.beta),l>this.beta)break;this.alpha=Math.max(this.alpha,l)}}else{l=1/0;for(const c of r){c.do(!1);const d=this.alphaBeta(e,t-1,!0);if(l=Math.min(d,l),c.searchCalculatedValue=d,c.undo(),t===this.iterativeDeepeningCurrentDepth&&console.log(c.algebraicNotation,this.alpha,this.beta),l<this.alpha)break;this.beta=Math.min(this.beta,l)}}return this.moves=r.toSorted((c,d)=>e.playerTurn.colour.isWhite?d.searchCalculatedValue-c.searchCalculatedValue:c.searchCalculatedValue-d.searchCalculatedValue),l}iterativeDeepening(e,t=this.iterativeDeepeningMaxDepth){console.time(`IterativeDeepending total for depth ${t}`);for(let i=1;i<=t;i++)this.iterativeDeepeningCurrentDepth=i,this.alpha=-1/0,this.beta=1/0,console.log("=================================================="),console.log("Starting best move calculation for",e.playerTurn.colour.name,"at depth",i),console.time(`iterativeDeepending at depth ${i}`),this.alphaBeta(e,i,e.playerTurn.colour.isWhite,this.moves),w.clearEvaluationCache(),this.bestMove=this.moves[0],console.log("Returned move",this.bestMove.algebraicNotation,"for value",this.bestMove.searchCalculatedValue),console.timeEnd(`iterativeDeepending at depth ${i}`);return console.timeEnd(`IterativeDeepending total for depth ${t}`),console.log("Number of positions evaluated:",this.numberOfPositions),this.bestMove=this.moves[0],this.bestMove}};s(B,"depth",3),s(B,"maxDepth",4);let K=B;self.onmessage=a=>{if(!a.data)return;const e=new U(a.data,new S("W",!1),new S("B",!1)),t=new K(e).search();postMessage(t)}})();
