var _=Object.defineProperty;var ee=(g,c,I)=>c in g?_(g,c,{enumerable:!0,configurable:!0,writable:!0,value:I}):g[c]=I;var s=(g,c,I)=>(ee(g,typeof c!="symbol"?c+"":c,I),I);(function(){"use strict";class g{constructor(e,t,i){s(this,"name");s(this,"id");s(this,"value");this.name=e,this.id=t,this.value=i}}const c={PAWN:new g("Pawn","P",1),KNIGHT:new g("Knight","N",3),KING:new g("King","K",0),QUEEN:new g("Queen","Q",9),ROOK:new g("Rook","R",5),BISHOP:new g("Bishop","B",3),EMPTY:new g("Empty","",0),NULL:new g("Null","-",-1)};function I(o){return o===o.toUpperCase()}function Y(o){return/^-?\d+$/.test(o)}let N;const j=new Uint8Array(16);function J(){if(!N&&(N=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!N))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return N(j)}const v=[];for(let o=0;o<256;++o)v.push((o+256).toString(16).slice(1));function X(o,e=0){return v[o[e+0]]+v[o[e+1]]+v[o[e+2]]+v[o[e+3]]+"-"+v[o[e+4]]+v[o[e+5]]+"-"+v[o[e+6]]+v[o[e+7]]+"-"+v[o[e+8]]+v[o[e+9]]+"-"+v[o[e+10]]+v[o[e+11]]+v[o[e+12]]+v[o[e+13]]+v[o[e+14]]+v[o[e+15]]}var $={randomUUID:typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};function Q(o,e,t){if($.randomUUID&&!e&&!o)return $.randomUUID();o=o||{};const i=o.random||(o.rng||J)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,e){t=t||0;for(let n=0;n<16;++n)e[t+n]=i[n];return e}return X(i)}class m{constructor(e,t,i,n,r){s(this,"castle");s(this,"enPassant");s(this,"colour");s(this,"halfMoveClock",0);s(this,"fullMoveClock",1);s(this,"id");s(this,"isCheckMate",!1);s(this,"isStaleMate",!1);this.castle=e,this.enPassant=t,this.colour=i,this.halfMoveClock=n,this.fullMoveClock=r,this.id=Q()}copy(e=!1){if(this.enPassant===null){const i=new m(this.castle,null,this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(i.id=this.id),i}const t=new m(this.castle,this.enPassant.copy(),this.colour.copy(),this.fullMoveClock,this.halfMoveClock);return e&&(t.id=this.id),t}}const u=class u{constructor(e){s(this,"id");this.id=e}get isWhite(){return this.id===u.whiteId}get isBlack(){return this.id===u.blackId}get isNull(){return this.id===u.nullId}get name(){return this.isBlack?u.blackName:u.whiteName}changePlayer(){return this.id===u.nullId?u.Null:(this.id=this.isBlack?u.whiteId:u.blackId,this)}isEqual(e){return u.areSameColour(this,e)}get opposite(){return this.id===u.nullId?u.Null:this.isBlack?new u(u.whiteId):new u(u.blackId)}copy(){return new u(this.id)}static get Black(){return u._black}static get White(){return u._white}static get Null(){return u._null}static areSameColour(e,t){return e.id===t.id}static areDifferentColourAndNotNull(e,t){return e.isNull||t.isNull?!1:e.id!==t.id}};s(u,"whiteId","W"),s(u,"blackId","B"),s(u,"blackName","Black"),s(u,"whiteName","White"),s(u,"nullId",""),s(u,"_black",new u("B")),s(u,"_white",new u("W")),s(u,"_null",new u(""));let w=u;const f=class f{constructor(e){s(this,"_index",f._nullIndex);e!==null&&(this._index=e)}get neighbours(){return this.index===null?{north:null,south:null,east:null,west:null,northEast:null,northWest:null,southEast:null,southWest:null}:{north:new f(this.index-8),south:new f(this.index+8),east:new f(this.index+1),west:new f(this.index-1),northEast:new f(this.index-7),northWest:new f(this.index-9),southEast:new f(this.index+9),southWest:new f(this.index+7)}}get index(){if(this._index===null)throw new Error("Position index is null");return this._index}set index(e){this._index=e}get an(){return f.indexToAn(this.index)}set an(e){this._index=f.anToIndex(e)}get rank(){const e=f.getRankOfIndex(this._index);if(this._index===null||e===null)throw new Error("Position rank is null");return e}set rank(e){this._index=f.rankFileToIndex(e,this.file)}get file(){const e=f.getFileOfIndex(this._index);if(this._index===null||e===null)throw new Error("Position file is null");return e}set file(e){this._index=f.rankFileToIndex(this.rank,e)}static ParseAn(e){const t=f.anToIndex(e);return t===null?null:new f(t)}isEqual(e){return this.index===e.index}copy(){return new f(this.index)}static fileDifference(e,t){return e.file===null||t.file===null?1/0:Math.abs(e.file-t.file)}static indexToAn(e){if(e===null)return"-";const t="abcdefgh",i=e%8,n=8-Math.floor(e/8);return t[i]+n}static anToIndex(e){const i="abcdefgh".indexOf(e[0]),n=8-Number(e[1]);return i===-1||n===-1?null:n+i*8}static rankFileToIndex(e,t){return t===null||e===null?null:e+(7-t)*8}static getRankOfIndex(e){return e===null?null:7-Math.floor(e/8)}static getFileOfIndex(e){return e===null?null:e%8}static isValidIndex(e){return e===null?!1:e>=0&&e<=63}};s(f,"_nullIndex",null);let a=f;class M{static getMoves(e,t){var i;try{const n=(i=this.moveCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static cacheMoves(e,t,i){this.moveCache[e]={[t]:i}}static clearCache(){console.log("Clearing cache"),this.moveCache={},this.evalCache={},this.scopeCache={}}static clearEvaluationCache(){this.evalCache={}}static cacheScope(e,t,i){this.scopeCache[e]={[t]:i}}static getScope(e,t){var i;try{const n=(i=this.scopeCache[e])==null?void 0:i[t];return{result:n!==void 0,moves:n!==void 0?n:[]}}catch(n){return console.log(n),{result:!1,moves:[]}}}static getEvaluation(e){try{const t=this.evalCache[e];return t!==void 0?{result:!0,evaluation:t}:{result:!1,evaluation:0}}catch{return{result:!1,evaluation:0}}}static cacheEvaluation(e,t){this.evalCache[e]=t}}s(M,"moveCache",{}),s(M,"scopeCache",{}),s(M,"evalCache",{});class q{static validateScope(e,t){return t.skipValidate?!0:!(!t.nullValidate||!this.position(t)||!this.cantHaveMoved(t)||!this.freePositions(e,t)||!this.pieceAtIndexesCantHaveMoved(t)||!this.pieceInPosition(t)||!this.isACapture(e,t)||!this.isAPromotion(t)||!this.castle(e,t))}static validate(e,t){return this.validateScope(e,t)&&this.willPutPlayerInCheck(e,t)&&this.indexesCantBeUnderAttack(t)}static castle(e,t){return t.isCastleMove?!!e.state.castle:!0}static willPutPlayerInCheck(e,t){t.do(!1);const i=e.isInCheck(t.piece.colour);return t.undo(),!i}static isAPromotion(e){if(e.piece.isPawn){const t=e.piece;return e.isPromotion&&e.end.rank===t.promotionRank||!e.isPromotion&&e.end.rank!==t.promotionRank}return!0}static position(e){return!(e.hasToStartAtRank&&e.start.rank!==e.hasToStartAtRank||a.fileDifference(e.start,e.end)>e.piece.maxFileDifference)}static cantHaveMoved(e){return!(e.piece.hasMoved&&e.pieceCantHaveMoved)}static isACapture(e,t){if(t.endPiece.colour.isEqual(t.piece.colour))return!1;if(!t.mustBeCapture||t.isCapture)return!0;if(e.state.enPassant!==null&&t.canBeEnpassant&&t.piece.isPawn&&(t.isEnpassantTake=e.state.enPassant.isEqual(t.end),t.isEnpassantTake)){if(e.state.enPassant.neighbours.north===null||e.state.enPassant.neighbours.south==null)return!1;t.willDestroy.push(e.state.enPassant.neighbours.north,e.state.enPassant.neighbours.south)}return t.isEnpassantTake}static freePositions(e,t){return t.mustBeFree.every(i=>e.getPieceAtPosition(i).isEmpty)}static pieceInPosition(e){return e.mustHavePieceAtIndex.piece&&e.mustHavePieceAtIndex.index?e.game.getPieceAtIndex(e.mustHavePieceAtIndex.index).isOfType(e.mustHavePieceAtIndex.piece):!0}static pieceAtIndexesCantHaveMoved(e){return e.pieceAtIndexesCantHaveMoved.every(t=>!e.game.getPieceAtIndex(t).hasMoved)}static indexesCantBeUnderAttack(e){const t=e.game.getScope({colour:e.piece.colour.opposite});return e.indexesCantBeUnderAttack.every(i=>!t.some(n=>n.end.index===i))}}class k{constructor(e,t,i){s(this,"start");s(this,"end");s(this,"piece");s(this,"willCreateEnPassant",!1);s(this,"willDestroy",[]);s(this,"isAttack",!0);s(this,"isEnpassantTake",!1);s(this,"isCastleMove",!1);s(this,"enPassantPositionCreated",null);s(this,"canBeEnpassant",!1);s(this,"mustBeFree",[]);s(this,"mustBeCapture",!1);s(this,"canBeCapture",!0);s(this,"hasToStartAtRank",null);s(this,"skipValidate",!1);s(this,"changePlayerAfterMove",!0);s(this,"extraMoves",[]);s(this,"value",null);s(this,"endPiece");s(this,"pieceCantHaveMoved",!1);s(this,"destoryedPieces",[]);s(this,"stateBefore");s(this,"castleChange","");s(this,"game");s(this,"isPromotion",!1);s(this,"promotionPiece",c.EMPTY.id);s(this,"hasMovedBefore");s(this,"stateId");s(this,"valueCalculated",!1);s(this,"searchCalculatedValue",0);s(this,"mustHavePieceAtIndex",{});s(this,"pieceAtIndexesCantHaveMoved",[]);s(this,"indexesCantBeUnderAttack",[]);this.start=new a(e.position.index),this.end=new a(t),this.piece=e,this.hasMovedBefore=this.piece.hasMoved,this.game=i,this.endPiece=i.getPieceAtPosition(this.end),this.stateBefore=i.state.copy(!0),this.stateId=i.state.id}get stateAfter(){return this.constructStateAfter()}get isCheck(){return this.endPiece.isKing&&w.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get simpleEvaluation(){return this.endPiece.type.value+this.piece.valueGrid[this.end.index]}get isCapture(){return w.areDifferentColourAndNotNull(this.piece.colour,this.endPiece.colour)}get nullValidate(){return!!this.endPiece}destroyPositions(){this.willDestroy.forEach(e=>{this.destoryedPieces.push(this.game.board[e.index]),this.game.destroyPieceAtPosition(e)})}undoDestroyPositions(){for(const e of this.destoryedPieces)this.game.placePieceAtPosition(e,e.position);this.destoryedPieces=[]}constructStateAfter(){const e=this.stateBefore.copy();return this.castleChange!==""&&this.castleChange.split("").forEach(t=>{e.castle=e.castle.replace(t,"")}),this.enPassantPositionCreated!==null?e.enPassant=this.enPassantPositionCreated:e.enPassant=null,(this.isCapture||this.piece.isPawn)&&(e.halfMoveClock=0),e.halfMoveClock++,this.piece.colour.isWhite&&e.fullMoveClock++,this.changePlayerAfterMove&&(e.colour=e.colour.opposite),e}doExtraMoves(e=!0){this.extraMoves.forEach(t=>{t.do(e)})}undoExtraMoves(){this.extraMoves.forEach(e=>{e.undo()})}handlePromotion(){if(this.isPromotion){const e=this.end.index;this.game.destroyPieceAtIndex(e);const t=this.piece.colour,i=F.generate(e,this.promotionPiece,t);this.game.placePieceAtPosition(i,this.end)}}undoPromotion(){this.isPromotion&&(this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.start))}validate(e){return q.validate(e,this)}validateScope(e){return q.validateScope(e,this)}do(e=!0){this.game.destroyPieceAtPosition(this.start),this.game.placePieceAtPosition(this.piece,this.end),this.game.state=this.stateAfter,this.destroyPositions(),this.handlePromotion(),this.doExtraMoves(e),this.piece.hasMoved=!0,e&&(this.game.moveHistory.push(this),M.clearCache())}undo(){this.game.placePieceAtPosition(this.piece,this.start),this.game.placePieceAtPosition(this.endPiece,this.end),this.game.state=this.stateBefore,this.undoDestroyPositions(),this.undoPromotion(),this.undoExtraMoves(),this.piece.hasMoved=this.hasMovedBefore}get algebraicNotation(){const e=this.piece.type.id,t=this.end.an,i=this.isCapture?"x":"",n=this.isPromotion?`=${this.promotionPiece}`:"",r=this.isCastleMove?"O-O":"";return`${e}${i}${t}${n}${r}`}}class E{constructor(e,t){s(this,"type");s(this,"colour");s(this,"selected");s(this,"hasMoved",!1);s(this,"maxFileDifference",0);s(this,"_position");s(this,"_moves",[]);s(this,"_scope",[]);s(this,"id");this._position=new a(e),this.colour=t,this.selected=!1,this.type=c.NULL,this.id=Q()}get valueGrid(){return new Array(64).fill(0)}set position(e){this._position=e}get position(){return this._position}positionalValue(e){return e.index===null?0:this.colour.isBlack?this.valueGrid[63-e.index]:this.valueGrid[e.index]}get directions(){return this.colour.isBlack?{forward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},left:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},right:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},forwardLeft:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},forwardRight:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backwardLeft:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backwardRight:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)}}:{forward:(e=1)=>{const t=this.position.index-e*8;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backward:(e=1)=>{const t=this.position.index+e*8;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},left:(e=1)=>{const t=this.position.index-e;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},right:(e=1)=>{const t=this.position.index+e;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},forwardLeft:(e=1)=>{const t=this.position.index-e*9;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},forwardRight:(e=1)=>{const t=this.position.index-e*7;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backwardLeft:(e=1)=>{const t=this.position.index+e*7;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)},backwardRight:(e=1)=>{const t=this.position.index+e*9;return this.position.index===null||!a.isValidIndex(t)?null:new a(t)}}}get moves(){return this._moves}get scope(){return this._scope}get isBlack(){return this.colour.isBlack}get isWhite(){return this.colour.isWhite}get isEmpty(){return this.type.id===c.EMPTY.id}get isKing(){return this.type.id===c.KING.id}get isPawn(){return this.type.id===c.PAWN.id}get isBishop(){return this.type.id===c.BISHOP.id}get isKnight(){return this.type.id===c.KNIGHT.id}get isRook(){return this.type.id===c.ROOK.id}get isQueen(){return this.type.id===c.QUEEN.id}generateMoves(e){const t=M.getMoves(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validate(e));return M.cacheMoves(this.id,e.state.id,i),i}_generateMoves(e){return console.log(this.type.name,e.state.id),[]}generateScope(e){const t=M.getScope(this.id,e.state.id);if(t.result)return t.moves;const i=this._generateMoves(e).filter(n=>n.validateScope(e));return M.cacheScope(this.id,e.state.id,i),i}select(){this.selected=!0}deselect(){this.selected=!1}directionMoveGenerator(e,t,i){var n;for(let r=1;r<=8;r++){const h=t(r);if(!h)continue;const p=new k(this,h.index,i);for(let l=1;l<=r-1;l++){if(!t(l))continue;const P=(n=t(l))==null?void 0:n.index;P!=null&&p.mustBeFree.push(new a(P))}const d=p.mustBeFree.length?p.mustBeFree[p.mustBeFree.length-1]:this.position;if(a.fileDifference(h,d)>1)return;e.push(p)}}appendMove(e,t,i){if(i!==null){const n=new k(this,i.index,e);t.push(n)}}isOfType(e){return this.type.id===e}}class T extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_BISHOP",[0,0,0,0,0,0,0,1,1,2,0,0,0,0,2,1,2,3,3,3,3,3,3,2,2,3,4,4,4,4,3,2,3,5,6,5,5,6,5,3,5,6,6,4,4,6,6,5,6,6,4,4,4,4,6,6,0,0,0,0,0,0,0,0]);this.maxFileDifference=8,this.type=c.BISHOP}get valueGrid(){return this.VALUE_GRID_BISHOP}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),i}}s(T,"id","B"),s(T,"name","Bishop"),s(T,"value");class A extends E{constructor(e){super(e,w.Null),this.type=c.EMPTY}}s(A,"id",""),s(A,"name","Empty"),s(A,"value",0);class R extends E{constructor(t,i){super(t,i);s(this,"KING_VALUE_GRID",[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,2,2,2,2,1,0,0,1,2,4,4,2,1,0,0,1,2,4,4,2,1,0,0,1,2,2,2,2,1,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0]);this.maxFileDifference=5,this.type=c.KING}get valueGrid(){return this.KING_VALUE_GRID}castleMoves(t){let i,n,r,h,p,d,l,P,C,W,L;this.isBlack?(i=2,n=3,r=0,P=[1,2,3],W=[3,4],C="q",h=6,p=5,d=7,l=[5,6],L=[4,5],C="k"):(i=58,n=59,r=56,P=[57,58,59],W=[59,60],C="Q",h=62,p=61,d=63,l=[61,62],L=[60,61],C="K");const Z=this.createCastleMove(i,t,r,n,P,W,C),z=this.createCastleMove(h,t,d,p,l,L,C);return[Z,z]}createCastleMove(t,i,n,r,h,p,d){const l=new k(this,t,i);l.isCastleMove=!0,l.isAttack=!1,l.changePlayerAfterMove=!1,l.mustHavePieceAtIndex={piece:"R",index:n},l.mustBeFree=h.map(C=>new a(C)),l.pieceAtIndexesCantHaveMoved=[n,this.position.index],l.castleChange=d,l.indexesCantBeUnderAttack=[this.position.index].concat(h),l.indexesCantBeUnderAttack=p;const P=new k(i.getPieceAtPosition(new a(n)),r,i);return P.skipValidate=!0,l.extraMoves.push(P),l}_generateMoves(t){let i=[];return this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.forward(1)),this.appendMove(t,i,this.directions.backward(1)),this.appendMove(t,i,this.directions.left(1)),this.appendMove(t,i,this.directions.right(1)),this.appendMove(t,i,this.directions.backwardLeft(1)),this.appendMove(t,i,this.directions.backwardRight(1)),this.appendMove(t,i,this.directions.forwardLeft(1)),this.appendMove(t,i,this.directions.forwardRight(1)),i.forEach(n=>{n.piece.isWhite&&(n.castleChange="KQ"),n.piece.isBlack&&(n.castleChange="kq")}),i=i.concat(this.castleMoves(t)),i}}s(R,"id","K"),s(R,"name","King"),s(R,"value");class D extends E{constructor(t,i){super(t,i);s(this,"maxFileDifference",2);s(this,"VALUE_GRID_KINGHT",[0,1,1,1,1,1,1,0,1,2,2,2,2,2,2,1,1,5,7,6,6,7,0,1,2,4,8,7,7,8,0,2,1,3,6,5,5,6,3,1,1,2,4,3,3,4,2,1,1,1,1,3,3,1,1,1,0,0,0,0,0,0,0,0]);this.type=c.KNIGHT}get valueGrid(){return this.VALUE_GRID_KINGHT}get knightEndPositionShift(){return[10,-10,17,-17,15,-15,6,-6]}_generateMoves(t){const i=[];return this.knightEndPositionShift.forEach(n=>{const r=this.position.index+n;if(this.position.index===null||!a.isValidIndex(r))return;const h=new k(this,r,t);i.push(h)}),i}}s(D,"id","N"),s(D,"name","Knight"),s(D,"value");class V extends E{constructor(t,i){super(t,i);s(this,"maxFileDifference",1);s(this,"VALUE_GRID_PAWN",[0,0,0,0,0,0,0,0,1,1,1,2,2,1,1,1,2,1,2,3,3,2,1,2,3,2,3,4,4,3,2,3,4,3,4,5,5,4,3,4,5,4,5,6,6,5,4,5,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8]);this.type=c.PAWN}get valueGrid(){return this.VALUE_GRID_PAWN}get promotionRank(){return this.isWhite?7:0}get startingRank(){return this.isWhite?1:6}get isAtStart(){return this.position.rank===this.startingRank}_generateMoves(t){let i=[];return i=this.generateMoveOneAheadMove(t,i),i=this.generateTwoAheadMove(t,i),i=this.generateAttackMoves(t,i),i}generatePromotionMoves(t,i,n){const r=n(1);if(!r)return[];const h=new k(this,r.index,t);h.isPromotion=!0,h.promotionPiece=c.QUEEN.id;const p=new k(this,r.index,t);p.isPromotion=!0,p.promotionPiece=c.KNIGHT.id;const d=new k(this,r.index,t);d.isPromotion=!0,d.promotionPiece=c.BISHOP.id;const l=new k(this,r.index,t);return l.isPromotion=!0,l.promotionPiece=c.ROOK.id,i.push(h),i.push(p),i.push(d),i.push(l),i}generateMoveOneAheadMove(t,i){const n=this.directions.forward(1);if(n===null)return i;const r=new k(this,n.index,t);return r.mustBeFree.push(n),r.canBeCapture=!1,r.isAttack=!1,i.push(r),i=this.generatePromotionMoves(t,i,this.directions.forward),i}generateAttackMoves(t,i){let n=[];return n=this.generatePromotionMoves(t,n,this.directions.forwardLeft),n=this.generatePromotionMoves(t,n,this.directions.forwardRight),this.appendMove(t,n,this.directions.forwardLeft(1)),this.appendMove(t,n,this.directions.forwardRight(1)),n=n.map(r=>(r.mustBeCapture=!0,r.canBeEnpassant=!0,r)),i=i.concat(n),i}generateTwoAheadMove(t,i){const n=this.directions.forward(1),r=this.directions.forward(2);if(!n||!r)return i;const h=new k(this,r.index,t);h.hasToStartAtRank=this.startingRank,h.mustBeFree.push(n),h.mustBeFree.push(r),h.canBeCapture=!1,h.willCreateEnPassant=!0,h.isAttack=!1;const p=this.directions.forward(1);return p!==null&&(h.enPassantPositionCreated=new a(p.index)),i.push(h),i}}s(V,"id","P"),s(V,"name","Pawn"),s(V,"value");class G extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_QUEEN",[1,1,1,3,3,1,1,1,1,2,2,4,4,2,2,1,1,2,3,5,5,3,2,1,3,4,5,7,7,5,4,3,3,4,5,7,7,5,4,3,1,2,3,5,5,3,2,1,1,2,2,4,4,2,2,1,1,1,1,3,3,1,1,1]);this.maxFileDifference=8,this.type=c.QUEEN}get valueGrid(){return this.VALUE_GRID_QUEEN}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forwardLeft,t),this.directionMoveGenerator(i,this.directions.forwardRight,t),this.directionMoveGenerator(i,this.directions.backwardLeft,t),this.directionMoveGenerator(i,this.directions.backwardRight,t),this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(G,"id","Q"),s(G,"name","Queen"),s(G,"value");class H extends E{constructor(t,i){super(t,i);s(this,"VALUE_GRID_ROOK",[3,3,3,3,3,3,3,3,3,6,6,6,6,6,6,3,3,6,7,7,7,7,6,3,3,6,7,8,8,7,6,3,3,6,7,8,8,7,6,3,3,6,7,7,7,7,6,3,3,6,6,6,6,6,6,3,3,3,3,3,3,3,3,3]);this.maxFileDifference=7,this.type=c.ROOK}get valueGrid(){return this.VALUE_GRID_ROOK}_generateMoves(t){const i=[];return this.directionMoveGenerator(i,this.directions.forward,t),this.directionMoveGenerator(i,this.directions.backward,t),this.directionMoveGenerator(i,this.directions.left,t),this.directionMoveGenerator(i,this.directions.right,t),i}}s(H,"id","R"),s(H,"name","Rook"),s(H,"value");class F{static generate(e,t,i){let n;switch(t){case c.KING.id:n=new R(e,i);break;case c.QUEEN.id:n=new G(e,i);break;case c.ROOK.id:n=new H(e,i);break;case c.BISHOP.id:n=new T(e,i);break;case c.KNIGHT.id:n=new D(e,i);break;case c.PAWN.id:n=new V(e,i);break;default:n=new A(e);break}return n}}class x{constructor(e="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"){s(this,"initialString");s(this,"board");s(this,"playerTurn");s(this,"castle");s(this,"enPassant");s(this,"halfMoveClock");s(this,"fullMoveClock");const t=e.split(" ");this.initialString=e,this.board=t[0],this.playerTurn=t[1],this.castle=t[2],this.enPassant=t[3],this.halfMoveClock=t[4],this.fullMoveClock=t[5]}static ParseFEN(e){const t=new x(e),i={};i.board=x.parseBoard(t);const n=x.parseCastleStateFEN(t),r=x.parseEnPassantFEN(t),h=x.parsePlayerTurnFEN(t),p=parseInt(t.halfMoveClock),d=parseInt(t.fullMoveClock);return i.state=new m(n,r,h,p,d),i}static parseBoard(e){const t=[],i=e.board.split("");let n=0;return i.forEach(r=>{if(r==="/")return;if(Y(r)){const p=parseFloat(r);for(let d=0;d<p;d++)t[n]=F.generate(n,c.EMPTY.id,w.Null),n++;return}const h=I(r)?w.White:w.Black;t[n]=F.generate(n,r.toLocaleUpperCase(),h),n++}),t}static parsePlayerTurnFEN(e){return new w(e.playerTurn.toLocaleUpperCase())}static parseCastleStateFEN(e){return e.castle}static parseEnPassantFEN(e){return e.enPassant==="-"?null:a.ParseAn(e.enPassant)}static generateFEN(e,t=!1){const i=new x;return i.board=x.generateBoardFEN(e),i.playerTurn=x.generatePlayerTurnFEN(e),i.castle=x.generateCastleStateFEN(e),i.enPassant=x.generateEnPassantFEN(e),i.halfMoveClock=x.generateHalfMoveClockFEN(e),i.fullMoveClock=x.generateTurnNumberFEN(e),t?`${i.board} ${i.playerTurn}`:`${i.board} ${i.playerTurn} ${i.castle} ${i.enPassant} ${i.halfMoveClock} ${i.fullMoveClock}`}static generateBoardFEN(e){let t="",i=0;for(let n=0;n<64;n++){const r=e.board[n];r.type.id===c.EMPTY.id?i++:(i>0&&(t+=i,i=0),t+=r.isWhite?r.type.id:r.type.id.toLowerCase()),n%8===7&&(i>0&&(t+=i,i=0),n!==63&&(t+="/"))}return t}static generatePlayerTurnFEN(e){return e.playerTurn.colour.id}static generateCastleStateFEN(e){return e.state.castle}static generateEnPassantFEN(e){return e.state.enPassant?e.state.enPassant.an:"-"}static generateHalfMoveClockFEN(e){return e.state.halfMoveClock.toString()}static generateTurnNumberFEN(e){return e.state.fullMoveClock.toString()}}class S{constructor(e,t){s(this,"_isHuman");s(this,"_colour");s(this,"_isPlayerTurn",!1);this._isHuman=t,this._colour=new w(e)}get isHuman(){return this._isHuman}set isHuman(e){this._isHuman=e}get isCpu(){return!this._isHuman}set isCpu(e){this._isHuman=!e}get colour(){return this._colour}}const b=class b{constructor(e=b.initalBoardFEN,t,i){s(this,"FEN");s(this,"board",[]);s(this,"moveHistory");s(this,"currentEvaluation");s(this,"selectedPiece",null);s(this,"whitePlayer");s(this,"blackPlayer");s(this,"state");this.whitePlayer=t,this.blackPlayer=i;const n=x.ParseFEN(e);this.board=n.board,this.state=n.state,this.FEN=n.FEN,this.currentEvaluation=0,this.moveHistory=[]}get playerTurn(){return this.state.colour.isWhite?this.whitePlayer:this.blackPlayer}get isWhitesMove(){return this.playerTurn.colour.isWhite}get isBlacksMove(){return this.playerTurn.colour.isBlack}resetBoard(e=!0,t=!1){this.whitePlayer=new S("W",e),this.blackPlayer=new S("B",t);const i=x.ParseFEN(b.initalBoardFEN);this.board=i.board,this.state=i.state,this.FEN=i.FEN,this.currentEvaluation=0,this.moveHistory=[]}isInCheck(e){for(const t of this.board){if(t.isEmpty||t.isKing||t.colour.isEqual(e))continue;const n=t.generateScope(this).some(r=>r.endPiece.isKing);if(n===!0)return n}return!1}selectPiece(e){return this.selectedPiece&&this.selectedPiece.deselect(),this.selectedPiece=this.getPieceAtIndex(e),this.selectedPiece&&this.selectedPiece.select(),this.selectedPiece}deselectPiece(){this.selectedPiece&&(this.selectedPiece.deselect(),this.selectedPiece=null)}getPieceAtIndex(e){return this.board[e]}getPieceAtPosition(e){try{return this.board[e.index]}catch(t){throw console.log(e,t),new Error("Invalid position")}}placePieceAtIndex(e,t){e.position=new a(t),this.board[t]=e}placePieceAtPosition(e,t){t.index!==null&&this.placePieceAtIndex(e,t.index)}destroyPieceAtIndex(e){return this.board[e]=new A(e)}destroyPieceAtPosition(e){return this.destroyPieceAtIndex(e.index)}changePlayer(){this.state.colour=this.state.colour.opposite}addMoveHistory(e){this.moveHistory.push(e)}removeMoveFromHistory(e){const t=this.moveHistory.indexOf(e);t>-1&&this.moveHistory.splice(t,1)}getMoves(e){let t=[];return this.board.forEach(i=>{if(this.filterPieces(e,i)){t=t.concat(i.generateMoves(this));return}},this),t}getScope(e){let t=[];return this.board.forEach(i=>{if(this.filterPieces(e,i)){t=t.concat(i.generateScope(this));return}},this),t}filterPieces(e,t){return e?!(e.colour&&!e.colour.isEqual(t.colour)||e.piece&&e.piece!==t.type.id||e.pieces&&!e.pieces.includes(t.type.id)||e.exludedPieces&&e.exludedPieces.includes(t.type.id)):!0}getPieces(e){const t=[];return this.board.forEach(i=>{this.filterPieces(e,i)&&t.push(i)},this),t}_destroyPositions(e){e.forEach(t=>{t.index!==null&&(this.board[t.index]=new A(t.index))})}_handleEnPassant(e){if(e.willCreateEnPassant){this.state.enPassant=e.enPassantPositionCreated;return}this.state.enPassant=null}};s(b,"initalBoardFEN","rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");let U=b;const y=class y{static simple(e){let t=0;const i=x.generateFEN(e,!0),n=M.getEvaluation(i);if(n.result===!0)return n.evaluation;for(const r of e.board)r.isEmpty||(r.colour.isWhite?(t+=y.positionalValue(r),t+=y.pieceValue(r)):(t-=y.positionalValue(r),t-=y.pieceValue(r)));return t+=this.mateValue(e),M.cacheEvaluation(i,t),t}static positionalValue(e){let t=0;return t+=e.positionalValue(e.position),t*y.positionMultiplyer}static pieceValue(e){return e.type.value}static mateValue(e){return y.isCheckMate(e)?e.playerTurn.colour.isWhite?-1/0:1/0:0}static isCheckMate(e){let t=!1;return e.isInCheck(e.playerTurn.colour)&&(t=e.getMoves({colour:e.playerTurn.colour}).length===0),t}};s(y,"positionMultiplyer",.1);let O=y;const B=class B{constructor(e,t=B.maxDepth){s(this,"iterativeDeepeningMaxDepth");s(this,"numberOfPositions",0);s(this,"game");s(this,"bestMove",null);s(this,"moves",[]);s(this,"iterativeDeepeningCurrentDepth",2);s(this,"forceReturn",!1);this.game=e,this.iterativeDeepeningMaxDepth=t}search(){const e=this.iterativeDeepening(this.game);return e===void 0?null:(this.bestMove=e,e)}alphaBeta(e,t,i,n,r,h=[]){if(n===0)return this.numberOfPositions++,O.simple(e);const p=h.length>0?h:e.getMoves({colour:r?w.White:w.Black}).sort((l,P)=>P.simpleEvaluation-l.simpleEvaluation);let d;if(r){d=-1/0;for(const l of p){l.do(!1);const P=this.alphaBeta(e,t,i,n-1,!1);if(d=Math.max(P,d),l.searchCalculatedValue=P,l.undo(),n===this.iterativeDeepeningCurrentDepth&&console.log(l.algebraicNotation,t,i),t=Math.max(t,d),d>=i)break}}else{d=1/0;for(const l of p){l.do(!1);const P=this.alphaBeta(e,t,i,n-1,!0);if(d=Math.min(P,d),l.searchCalculatedValue=P,l.undo(),n===this.iterativeDeepeningCurrentDepth&&console.log(l.algebraicNotation,t,i),i=Math.min(i,d),d<=t)break}}return this.moves=p.toSorted((l,P)=>e.playerTurn.colour.isWhite?P.searchCalculatedValue-l.searchCalculatedValue:l.searchCalculatedValue-P.searchCalculatedValue),d}iterativeDeepening(e,t=this.iterativeDeepeningMaxDepth){console.time(`IterativeDeepending total for depth ${t}`);for(let i=2;i<=t;i+=2){this.iterativeDeepeningCurrentDepth=i,console.log("=================================================="),console.log("Starting best move calculation for",e.playerTurn.colour.name,"at depth",i),console.time(`iterativeDeepending at depth ${i}`);const n=-1/0,r=1/0;this.alphaBeta(e,n,r,i,e.playerTurn.colour.isWhite,this.moves),M.clearEvaluationCache(),this.bestMove=this.moves[0],console.log("Returned move",this.bestMove.algebraicNotation,"for value",this.bestMove.searchCalculatedValue),console.timeEnd(`iterativeDeepending at depth ${i}`)}return console.timeEnd(`IterativeDeepending total for depth ${t}`),console.log("Number of positions evaluated:",this.numberOfPositions),this.bestMove=this.moves[0],this.bestMove}};s(B,"depth",3),s(B,"maxDepth",4);let K=B;self.onmessage=o=>{if(!o.data)return;const e=new U(o.data,new S("W",!1),new S("B",!1)),t=new K(e).search();postMessage(t)}})();
